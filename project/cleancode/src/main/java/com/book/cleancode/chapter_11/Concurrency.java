package com.book.cleancode.chapter_11;

public class Concurrency {

    public static void main(String[] args) {

        // 동시성
        // 객체는 처리의 추상화다, 스레드는 일정의 추상화다.
        // 동시성과 깔끔한 코드는 양립하기 어렵다.
        // 동시성은 Coupling (결합) 을 없애는 전략이다. 즉 무엇과 언제를 분리하는 전력이다.
        // 스레드가 하나인 프로그램은 무엇과 언제가 상당히 밀접하다.

        // 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
        // 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다.
        // 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.

        // 1. 동시성은 항상 성능을 높여준다.


        // 2. 동시성을 구현하여도 설계는 변하지 않는다.


        // 3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

        // 권장 사항 !! : 동시성 코드는 다른 코드와 분리하라 !!!
        // 권장 사항 !! : 자료를 캡슙화 하라 공유 자료를 최대한 줄여라 !!

        // 자바에서 synchronized 키워드를 사용하면 락을 설정한다.
        // 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
        // 락은 스레드를 지연 시키고 부하를 가중 시칸다.



    }
}


// 인스턴스 X 를 생성하고 lastUsedId 필드를 42 로 설정한 다음 두 스레드가 해당 인스턴스를 공유한다.
// 이제 두 스레드가 getNextId() 를 호출한다고 가정하면 결과는 셋 중 하나이다.

// 1. 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastUsedId 는 44 가 된다.

// 2. 한 스레드는 44를 받는다. 다 른 스레드는 43을 받는다. lastUsedId 가 44 가 된다.

// 3. 한 스레드는 43을 받는다. 다른 스레드는 43을 받는다. lastUsedId 가 43 이 된다.

// 두 스레드가 같은 변수를 동시에 참조하면 세번째와 같이 놀라운 경우가 발생한다.
// 이를 분석하려면 JIT 에 대한 이해가 필요하다.
// 이러한 문제를 해결하는 방안으로 synchronized 키워드로 보호하라고 권장한다. 이러한 임계영역의 수를 줄이는 기술도 중요하다.

class X {
    private int lastIdUsedId;

    public int getNextId() {
        return ++lastIdUsedId;
    }
}