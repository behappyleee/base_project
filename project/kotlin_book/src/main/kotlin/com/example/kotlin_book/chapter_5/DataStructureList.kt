package com.example.kotlin_book.chapter_5

class DataStructureList {

    // 데이터 구조는 프로그래밍이나 일상 생활에서 가장 중요한 개념
    // 컬렉션 - 컴퓨터를 사용한 계산에서 데이터 구조는 어떤 주어진 타입의 객체가 여러개 모인 것
    // 컬렉션은 서로 관계가 있는 데이터 원소들을 모아둔 그룹

    // 선형 컬렉션 - 각 원소가 다음 원소와 연관되어 있음 (대표적인 예 List)
    // 연관 컬렉션 - 어떤 타입에 속한 값 o 와 그 값에 대응하는 값 v 로 이루어진 연관관계를 모아둔 컬렉션
    // (대표적인 예) set, map)
    // 그래프 컬렉션 - 각 원소가 여러 다른 원소와 연관 되어 있는 컬렉션 (가장 대표적인 예) tree)

    // 컴퓨터 공학에서는 입력 크기에 변함에 따라 알고리즘의 복잡도가 어떻게 변하는 지를 표현

    // Big O 표기법
    // O(1) - 연산에 필요한 시간이 상수, 상수라는 말은 원소가 한 개인 리스트를 처리하는데 걸리는 시간이나
    // 원소가 n 개인 리스트를 처리하는데 걸리는 시간이 1배로 같음

    // O(log(n)) - 길이가 n 인 리스트를 처리하려면 길이가 1인 리스트를 처리하는 데 걸리는 시간의 log(n) 배 시간이 걸림
    // O(n) - 길이가 n 인 리스트를 처리하려면 길이가 1인 리스트를 처리하는데 걸리는 시간의 n 배가 걸림
    // O(n제곱) - 길이가 n 인 리스틀ㄹ 처리하려면 길이가 1인 리스트를 처리하는 데 걸리는 시간의 n제곱 배의 시간이 걸림
    
    // 모든 유형 연산의 대하여 O(1) 성능을 제공하는 데이터 구조를 만들 수 있는것이 이상적 -> 아직 그런 성능은 불가능

    // 대부분의 데이터 구조는 원소를 삽입하거나 삭제함에 따라 변화함
    // 제자리 갱신 (update in place) - 데이터 구조의 상태를 변이해 데이터 구조를 이루는 원소들을 바꾸는 방식
    // 모든 프로그램이 단일 스레드로 이루어 졌을 때 좋은 방법이라고 여겨졌지만 모든 프로그램이 다 중 스레드로 돌아가고 있는 현재
    // 이 방식은 훨씬 나쁜 방식이다.

    // --> 해법은 불변 데이터 구조를 사용하는 것이다. 이미 존재하는 내용을 변경하는 대신에 새로운 상태를 표현하는
    // 데이터를 새로 만든다. 원소를 기존 리스트에 추가하는 대신에 추가 된 원소가 더 들어 있는 리스트를 새로 하나 만든다.

    // Kotlin 은 불변 리스트와 가변 리스트를 제공
    // 가변 리스트는 자바 리스트와 똑같이 작도으 불변 리스트는 최소한 직접적인 연산을 통해서는 변경이 불가능


}

fun main(args: Array<String>) {

}
