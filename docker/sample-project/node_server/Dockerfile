# 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함 됨

# 일반적으로 FROM 으로 시작 됨 (운영체제 레이어가 필요함)
# node 이미지는 docker hub 에 있음 (docker hub 에 있어도 컨테이너를 처음 실행 시 이 이미지가 로컬로 캐시 가 되어 로컬에도 존재하게 됨)

# 1. node 이미지를 docker hub 에서 가져옴
FROM node:20

# WORKDIR 커맨드는 해당 Dockerfile 에서 실행하는 모든 명령어를 /app 내부에서 실행할 수 있도록 해 줌
# WORKDIR 는 복사한 파일 경로인 /app 을 할당, 도커에게 모든 후속 명령어는 /app 내부에서 실행할 수 있도록 해 줌
# 작업 디렉토리를 /app 으로 설정
WORKDIR /app

# 2. 프로젝트 복사 경로를 지정
# 기본적으로 여기에서 2개의 경로를 지정 함
# 첫번쨰 경로는 컨테이너의 외부 (이미지로 복사되어야 할 파일들이 있는 곳, 그냥 . 이면 Dockerfile 이 있는 경로와 동일 경로)
# 두번쨰 /app 는 이미지 내부의 경로임 (모든 이미지와 이미지를 기반으로 생성 된 모든 컨테이너에는 로컬 머신의 파일 시스템에서 완전히 분리 된)
# 자체 내부 파일 시스템이 있음 도커 내부에 숨겨져 있음, 서브 폴더에 복사 하는 것을 추천

# WORKDIR 를 적용하지 않았을 떄
# COPY . /app

# WORKDIR 를 적용하였을 떄
# ./ 는 도커 컨테이너의 현재 작업 디렉토리를 의미
# WORKDIR 를 /app 으로 변경 했기에 
# RUN 뿐만 아니라 COPY 명령어도 WORKDIR 기준으로 실행이 됨 (상대경로로 설정 함)
COPY . ./

# 해당 방식으로 작성해 도 됨 (WORKDIR 설정 하여도)
# COPY ./app

# 3. npm install
# 모든 파일을 도커 컨테이너 내부 경로에 파일 들을 복사 후 명령어를 실행
# 디폴트로 모든 명령은 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행이 됨, 디폴트로 그 작업 디렉토리는
# 컨테이너 파일 시스템의 루트 폴더임
# 여기에서는 코드를 app 폴더에 복사를 하였기에 app 폴더 내에서 실행이 되어야 함
RUN npm install

# 마지막 명령은 모든 작업이 완료 되었을 때 서버를 실행하여야 함
# 이렇게 할 수 도 있지만 이거는 이미지가 빌드 될 때 마다 실행이 되기에 이 명령은 올바르지 않음
# 왜냐하면 RUN 이라는 명령어는 Image 가 빌드 될 떄 마다 실행이 되는 데 굳이 Image Build 시에 server 를 실행할 필요는 없음
# 오직 Container 를 시작시에만 server.mjs 를 실행시켜주면 됨
# RUN node server.mjs

# Image 는 컨테이너의 템플릿이여야 함 (Image 를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행하는 것임)

# 컨테이너를 시작하는 경우에만 서버를 시작하고 싶음 (CMD 명령어를 이용 - 컨테이너를 시작시에만 해당 명령어를 사용)
# CMD 명령어는 이미지가 빌드 될 떄 실행되는 것이 아닌 컨테이너가 실행 시 명령어를 전달

# Docker 에 listen port 를 노출 시켜 줌
# EXPOSE 는 Documentation 같은 목적으로 노출을 시켜줌 즉 아무것도 역할은 하지 않음
# 실제로 EXPOSE 명령어는 실행하는데 아무런 지장이 없지만 추가하는 것을 권장 함
EXPOSE 80

# DOcker 자체 내부 네트워크도 있음 컨테이너 내부의 노드 어플리케이션 80 을 수신할 수 있도록 해주어야 함
CMD ["node", "server.mjs"]

# docker 실행 시 명령어로 docker run -p (-p 옵션은 publish 의미임) 이를 통해 도커에게 어떤 로컬 포트가 있는 지 알려줄 수 있음
# 우리의 로컬 머신의 어떤 포트가 도커 내부 특정 포트에 액세스 할 수 있는 지
# 로컬 포트 3000 에 publish 가 되었기에 잘 작동 함
# 로컬 3000 port 로 도커 내부 80 포트에 접근이 가능
# ex) docker run -p 3000:80 {dockerImage}


