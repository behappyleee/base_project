package com.sample.study.coroutine.controller

// Coroutine 은 일반적인 동기 방식의 코드 스타일을 유지하면서 비동기를 간단하게 구현이 가능
// Coroutine -> 동시성 프로그래밍, 코루틴은 코루틴이 시작된 스레드를 중단하지 않으면서 비동기적으로 실행되는 코드
// 보통 일반적인 함수는 중단되는 개녑없이 어떤 루틴이 있으면 해당 루틴을 끝까지 실행 후 종료되고 빠져나오는 방식이면
// 코루틴은 진입하는 입구와 나오는 출구점이 여러개 임
// Coroutine 은 Main Thread 가 blocking 되는 부분에 대해서도 도움을 주고
// 비동기 처리 코드를 순처적인 코드로 만들 수 있게 해줌

// 동기 - 순차적인 작업 실행, 어떤 일을 처리할 때 하나의 작업만을 할 수 있음
// 비동기 - 여러개의 작업을 동시에 하는 것, ex) 티비를 보면서 돈을 계산한다 ...
// 코드 내에서 뿐만 아니라 다른 무거운 작업을 실행 시 사용자는 그떄까지 기다리고 있어야 함

// 코루틴 - 비선점적 멀티태스킹을 위한 서브 루틴을 일반화한 컴퓨터 프로그래밍 구성요소
// 비 선점적 - 하나의 프로세스가 CPU 를 할당 받으면 종료되기 전까지 다른 프로세스가 CPU 를 강제로 차지가 안 됨 (코루틴)
// 선점적 - 하나의 프로세스가 다른 프로세스 대신에 프로세서 (CPU)를 강제로 차지를 할 수 가 없음 (쓰레드)

// 따라서 코루틴은 병행성은 제공 하지만 병렬성은 제공하지 않음
// 병행성 : 논리적으로 병렬로 작업이 실행되는 것처럼 보이는 것
// 병렬성 : 물리적으로 병렬로 작업이 실행 되는 것

// 프로그램은 여러 루틴의 조합으로 진행이 되는데 메인 루틴과 서브 루틴으로 나뉨
// 메인 루틴 - 프로그램 전체의 개괄적인 동작으로 main 함수에 의해 수행되는 흐름
// 서브 루틴 - 반복적인 기능을 모은 동작으로 main 함수 내에서 실행되는 개별 함수의 흐름

fun main() {
    // 일반적은 프로그램 루틴은 메인 루틴과 다양한 서브 루틴이 존재, 보통 메인 안에서 호출되는 루틴들이 서브 루틴들임
    // 보통 프로그램 시작하는 곳이 메인 루틴 메인 루틴은 다양한 서브 루틴들로 이루어져 있음
    // 서브 루틴은 진입 시점과 종료 시점이 명확함, 일반적으로 함수 호출 시점인 return 에서 종료 하게 됨
    println("[THREAD NAME ] : " + Thread.currentThread().name + " start ..")
    test1()
    test2()
    test3()
}

fun test1() {
    println("[EXECUTE TEST 1 METHOD 1]")
    Thread.sleep(1000)
}

fun test2() {
    println("[EXECUTE TEST 2 METHOD 2]")
}

fun test3() {
    println("[EXECUTE TEST 3 METHOD 3]")
}

class CoroutineTest {


}